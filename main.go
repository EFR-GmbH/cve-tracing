package main

import (
	"encoding/json"
	"fmt"
	"github.com/gin-gonic/gin"
	"io/ioutil"
	"log"
	"net/http"
	"strconv"
	"sync"
)

var configuration Configurations

func onError(err error) {
	if err != nil {
		log.Fatalln(err)
	}
}
func dbInsertCVE(cpe string, cve CveComplex) {

	for i := 0; i < cve.TotalResults; i++ {
		sql := fmt.Sprintf("INSERT IGNORE INTO cve(cpe, cveid, description, publishedDate, impactScore, explpoytabilityScore, internalServerity, solved) VALUES ('%s', '%s', '%s', '%s', %f, %f, %f, %t)",
			cpe,
			cve.Result.CVEItems[i].Cve.CVEDataMeta.ID,
			escape(cve.Result.CVEItems[i].Cve.Description.DescriptionData[0].Value),
			cve.Result.CVEItems[i].PublishedDate,
			cve.Result.CVEItems[i].Impact.BaseMetricV3.ImpactScore,
			cve.Result.CVEItems[i].Impact.BaseMetricV3.ExploitabilityScore,
			0.0,
			false)
		// fmt.Println(sql)
		_, err := Db.Exec(sql)
		onError(err)
	}
}

func getCVE(wgrp *sync.WaitGroup) {
	resultsPerPage := 20
	baseURI := "https://services.nvd.nist.gov/rest/json/cves/1.0/"
	startIndex := 0
	// var query string
	for _, cpe := range configuration.Cpe {
		fmt.Println(cpe)
		var cve CveComplex
		for {
			var cveTmp CveComplex
			query := fmt.Sprintf(baseURI+"?cpeMatchString=%s&startIndex=%d", cpe, startIndex)
			resp, err := http.Get(query)
			onError(err)

			body, err := ioutil.ReadAll(resp.Body)
			onError(err)

			err = json.Unmarshal(body, &cveTmp)
			onError(err)
			// Check if struct cve already contains values
			if cve.ResultsPerPage != 0 {
				cve.Result.CVEItems = append(cve.Result.CVEItems, cveTmp.Result.CVEItems...)
				cve.ResultsPerPage += cveTmp.ResultsPerPage
			} else {
				// Break here, no cve exists for a given library
				if cveTmp.ResultsPerPage == 0 {
					break
				}

				cve = cveTmp
			}

			// the default exit condition, all results have been gathered
			if cve.ResultsPerPage >= cve.TotalResults {
				break
			}
			startIndex = startIndex + resultsPerPage

		}

		for i := 0; i < cve.TotalResults; i++ {
			fmt.Printf("%+v\n", cve.Result.CVEItems[i].Cve.CVEDataMeta.ID)
			// fmt.Printf("%+v\n", cve.Result.CVEItems[i].Cve.Description.DescriptionData[0].Value)
		}
		dbInsertCVE(cpe, cve)
	}
	wgrp.Done()
}

func readAllCVEFromDB() []CveSimple {
	sql := "SELECT * from cve;"
	rows, err := Db.Query(sql)
	onError(err)
	defer rows.Close()

	var cves []CveSimple
	for rows.Next() {
		var cve CveSimple
		err = rows.Scan(&cve.Id, &cve.Cpe, &cve.CveId, &cve.Description, &cve.PublishedDate, &cve.ImpactScore,
			&cve.ExploytabilityScore, &cve.InternalSeverity, &cve.solved)
		onError(err)
		cves = append(cves, cve)
	}
	return cves
}
func GetHandler(c *gin.Context) {
	c.JSON(http.StatusOK, readAllCVEFromDB())
}

func startServer() {
	r := gin.Default()
	// r.NoRoute(func(c *gin.Context) {
	// 	dir, file := path.Split(c.Request.RequestURI)
	// 	ext := filepath.Ext(file)
	// 	if file == "" || ext == "" {
	// 		c.File("./ui/dist/ui/index.html")
	// 	} else {
	// 		c.File("./ui/dist/ui/" + path.Join(dir, file))
	// 	}
	// })

	r.GET("/cve", GetHandler)

	err := r.Run(":" + strconv.Itoa(configuration.Server.Port))
	onError(err)
}

func main() {
	var wgrp sync.WaitGroup

	wgrp.Add(1)
	setConfig(&configuration)
	dbOpen(configuration)
	go getCVE(&wgrp)
	wgrp.Wait()
	wgrp.Add(1)
	go startServer()
	wgrp.Wait() // Wait forever
}
